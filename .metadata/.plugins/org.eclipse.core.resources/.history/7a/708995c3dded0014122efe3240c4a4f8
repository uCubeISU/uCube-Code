/*
 *     uCube is a motion controlled interactive LED cube.
 *     Copyright (C) 2014  Jeramie Vens
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * @addtogroup usci
 * @{
 * @file      Usci.cpp
 * @author    Jeramie Vens
 * @date      April 25, 2015: Created
 */

#include <msp430.h>
#include <stdlib.h>
#include "Usci.h"

namespace ucube{

Usci* Usci::usciACallbacks = NULL;
Usci* Usci::usciBCallbacks = NULL;

/**
 * @details    Create a new USCI protocol attached to the given channel.
 * 	           The USCI protocol will register the callback methods for the
 * 	           Rx and Tx events on the channel.
 * @param      channel
 *                  The USCI channel to attach this serial protocol to
 */
Usci::Usci(UsciChannel::UsciChannel channel)
	: usciChannel(channel)
{
	switch(channel)
	{
	case UsciChannel::USCIA:
		Usci::usciACallbacks = this;
		break;
	case UsciChannel::USCIB:
		Usci::usciBCallbacks = this;
		break;
	}
	//this->usciChannel = channel;
}

Usci::~Usci()
{
	switch(this->usciChannel)
	{
	case UsciChannel::USCIA:
		Usci::usciACallbacks = NULL;
		break;
	case UsciChannel::USCIB:
		Usci::usciBCallbacks = NULL;
		break;
	}
}

inline unsigned char Usci::SerialReadByte(void)
{
	switch(this->usciChannel)
	{
	case UsciChannel::USCIA:
		return UCA0RXBUF;
	case UsciChannel::USCIB:
		return UCB0RXBUF;
	default:
		return 0;
	}
}

inline void Usci::SerialSendByte(unsigned char byte)
{
	switch(this->usciChannel)
	{
	case UsciChannel::USCIA:
		UCA0TXBUF = byte;
		return;
	case UsciChannel::USCIB:
		UCB0TXBUF = byte;
		return;
	}
}

inline void Usci::SetUsciResetMode(bool reset)
{
	switch(this->usciChannel)
	{
	case UsciChannel::USCIA:
		if(reset)
			UCA0CTL1 |= UCSWRST;
		else
			UCA0CTL1 &= ~UCSWRST;
		break;
	case UsciChannel::USCIB:
		if(reset)
			UCB0CTL1 |= UCSWRST;
		else
			UCB0CTL1 &= ~UCSWRST;
		break;

	}
}

inline void Usci::SetUsciControl0(unsigned char value)
{
	switch(this->usciChannel)
	{
	case UsciChannel::USCIA:
		UCA0CTL0 = value;
		break;
	case UsciChannel::USCIB:
		UCB0CTL0 = value;
		break;
	}
}

inline void Usci::SetUsciControl1(unsigned char value)
{
	switch(this->usciChannel)
	{
	case UsciChannel::USCIA:
		UCA0CTL1 = value | (UCA0CTL1 & UCSWRST);
		break;
	case UsciChannel::USCIB:
		UCB0CTL1 = value | (UCB0CTL1 & UCSWRST);
		break;
	}
}

inline void Usci::SetUsciBaud(unsigned short value)
{
	switch(this->usciChannel)
	{
	case UsciChannel::USCIA:
		UCA0BR0 = value;
		UCA0BR1 = value >> 8;
		break;
	case UsciChannel::USCIB:
		UCB0BR0 = value;
		UCB0BR1 = value >> 8;
		break;
	}
}

#pragma vector=USCIAB0RX_VECTOR
__interrupt void USCIAB0RX_ISR(void)
{
	if(IFG2 & UCA0RXIFG && Usci::usciACallbacks)
		Usci::usciACallbacks->OnSerialRx(UsciChannel::USCIA);
	if(IFG2 & UCB0RXIFG && Usci::usciBCallbacks)
		Usci::usciBCallbacks->OnSerialRx(UsciChannel::USCIB);
}

#pragma vector=USCIAB0TX_VECTOR
__interrupt void USCIAB0TX_ISR(void)
{
	if(IFG2 & UCA0TXIFG && Usci::usciACallbacks)
		Usci::usciACallbacks->OnSerialTx(UsciChannel::USCIA);
	if(IFG2 & UCB0TXIFG && Usci::usciBCallbacks)
		Usci::usciBCallbacks->OnSerialTx(UsciChannel::USCIB);

}

}
